// A few polynomial-time primitives for the AI.

var terrain = require('terrain-gen');

// Given a tile position and something to build, find the nearest tile where it
// can be built, or null.
function findConstructionLocation(humanity, tile, b) {
  var dependencies = terrain.buildingDependencies[b];
  dependencies = dependencies || [];
  var sameTileDependency = terrain.buildingTileDependency[b];
  // Aggregate all terrain-based requirements.
  // That includes terrain and things which cannot be built.
  if (isGenerated(sameTileDependency)) {
    var sameTileTerrainDependency = sameTileDependency;
  }
  // List of [number, building type].
  var terrainDependencies = dependencies.filter(function(dep) {
    return isGenerated(dep[1]);
  });
  return humanity.findNearest(tile, function(tile) {
    // Current tile requirement.
    if (sameTileTerrainDependency) {
      var humanityTile = humanity(tile);
      if (!isOneOf(terrain(tile).type, sameTileTerrainDependency)) {
        if (humanityTile == null) { return false; }
        if (!isOneOf(humanityTile.b, sameTileTerrainDependency)) {
          return false;
        }
      }
    }
    // For each surrounding dependency, count the surroundings.
    for (var i = 0; i < terrainDependencies.length; i++) {
      var dependencyCount = terrainDependencies[i][0];
      var dependencyType = terrainDependencies[i][1];
      var count = 0;
      for (var j = 0; j < 6; j++) {
        var neighbor = terrain.neighborFromTile(tile, j);
        var humanityNeighbor = humanity(neighbor);
        if (terrain(neighbor).type === dependencyType
          || (humanityNeighbor && humanityNeighbor.b === dependencyType)) {
          count++;
        }
      }
      if (count < dependencyCount) {
        return false;
      }
    }
    return true;
  });
}

// Given a building type (number), returns true if it can be built.
function isBuilding(b) {
  return terrain.buildingTypes.indexOf(b) >= 0;
}

// Given a dependency item (building, terrain, resource), returns true if that
// dependency was generated by the world.
function isGenerated(b) {
  // b can be negative if it is a resource.
  return  b >= 0 && !isBuilding(b);
}

// buildings: list of building types (as numbers).
// b: building.
// Returns true if b is either one of the buildings in the list.
function isOneOf(b, buildings) {
  return buildings.indexOf(b) >= 0;
}

// Compute the set of buildings to build, in order, to be able to build
// something specific, on a tile.
// b: terrain.tileTypes
// tile: {q,r}
// forbiddenTiles: [{q,r}]
// Returns a list of {tile: {q,r}, building: type} that needs to be
// constructed, in the correct order (see terrain.tileTypes).
// FIXME: take unwalkable tiles (water, …) into account.
// FIXME: don't destroy buildings which cost resources.
function dependencyBuilds(humanity, b, tile, forbiddenTiles) {
  forbiddenTiles = forbiddenTiles || [];
  // List of {tile: {q,r}, building: type}.
  var buildings = [];
  var dependencies = terrain.buildingDependencies[b];
  dependencies = dependencies || [];
  for (var i = 0; i < dependencies.length; i++) {
    var number = dependencies[i][0];
    var buildingType = dependencies[i][1];
    // Ignore resource requirements…
    if (buildingType < 0) { continue; }
    // Ignore terrain requirements…
    if (!isBuilding(buildingType)) { continue; }
    var dependencySatisfied = false;
    // Choose a random starting neighbor, check all neighbors.
    var startingNeighbor = (Math.random() * 6)|0;
    for (var j = 0; j < 6; j++) {
      var n = (j + startingNeighbor) % 6;
      var neighbor = terrain.neighborFromTile(tile, n);
      // Is this neighbor authorized?
      if (isOneOf(neighbor, forbiddenTiles)) { continue; }
      var neighborBuildings =
        dependencyBuilds(buildingType, neighbor, forbiddenTiles);
      if (neighborBuildings != null) {
        // We can build that.
        buildings = buildings.concat(neighborBuildings);
        // We mustn't destroy this tile, it is needed to build `b`.
        forbiddenTiles = forbiddenTiles.concat(tile);
        number -= 1;
        if (number <= 0) {
          // We have build everything of this type of building.
          dependencySatisfied = true;
          break;
        }
      }
    }
    if (!dependencySatisfied) { return null; }
  }
  // We have built all the dependencies, now we can build the final piece.
  buildings.push({ tile: tile, building: b });
  return buildings;
}

// Find nearest terrain where nothing is built.
// size: number of layers that must be empty around the tile.
function findNearestEmpty(humanity, tile, size) {
  // Check whether the tile contains buildings.
  var builtTerrain = function builtTerrain(tile) {
    var human = humanity(tile);
    if (human === undefined) { return false; }
    if (human.b == null) { return false; }
    return true;
  };

  return humanity.findNearest(tile, function(tile) {
    // If it finds no built terrain, we're good to go.
    return !humanity.findNearest(tile, builtTerrain, size);
  });
}



// Managing projects.
// Each plan corresponds to a group of folks that must accomplish it.

// A group corresponds to a camp. It is on a unique tile.
// tile: {q,r}
// camp: a camp object. See humanity.js.
function Group(tile, camp) {
  this.tile = tile;
  this.camp = camp;
}


// camp: a camp object. See humanity.js.
function Strategy(camp, humanity) {
  this.camp = camp;
  this.humanity = humanity;
  // Active projects.
  // Each project is {type, groups, target, builds, camp}.
  this.projects = [];  // Ordered by priority.
  // Active groups.
  this.groups = [];
  this.groupFromKey = Object.create(null);
}

// Strategy gives primitives for elementary projects
// that an AI can choose to do.

// Projects are {type, groups, target, builds, camp}.
// - type: see `projectType`.
// - groups: a list of `Group`.
// - target: tile {q,r} around which that project takes place.
// - builds: list of {tile:{q,r}, building:tileTypes} to make
//   before completing the project.
// - camp: campId towards which the project is targeted.

var projectType = {
  build: 0,
  conquer: 1,
  war: 2,
};
var projectTypeList = Object.keys(projectType);

Strategy.prototype = {

  // A few functions to simplify input parameters.
  findNearestEmpty: function(tile, size) {
    return findNearestEmpty(this.humanity, tile, size);
  },
  findConstructionLocation: function(tile, b) {
    return findConstructionLocation(this.humanity, tile, b);
  },
  dependencyBuilds: function(b, tile, forbiddenTiles) {
    return dependencyBuilds(this.humanity, b, tile, forbiddenTiles);
  },

  // Group creation below.
  //

  // Find a group. If the tile = {q,r} is given,
  // find the group closest to that tile.
  // Returns the group.
  addGroup: function(tile) {
    // It needs to be a group we don't currently count.
    var tiles = this.camp.inhabitedTiles;
    var chosenTile;
    var closest = MAX_INT;
    for (var i = 0; i < tiles.length; i++) {
      var tileKey = terrain.keyFromTile(tiles[i]);
      // Skip groups we already control.
      if (this.groupFromKey[tileKey] !== undefined) {
        continue;
      }
      // FIXME: don't include tiles controlled by players.
      // Locate the closest group to the target tile.
      var distance = distanceBetweenTiles(tile, tiles[i]);
      if (distance < closest) {
        closest = distance;
        chosenTile = tiles[i];
      }
    }
    var group = new Group(chosenTile, this.camp);
    this.groups.push(group);
    this.groupFromKey[terrain.keyFromTile(chosenTile)] = group;
    return group;
  },

  // Stop controlling group at that index (see `this.groups`).
  removeGroup: function(index) {
    delete this.groupFromKey[terrain.keyFromTile(this.groups[index].tile)];
    this.groups.splice(index, 1);
  },

  // FIXME: add methods to improve the group for a particular project.

  // Project creation below.
  //

  // Create a building.
  // FIXME: notice lack of resources needed for building.
  buildProject: function(buildingType) {
    // List of tileKeys
    var tiles = this.camp.inhabitedTiles;
    // Pick a random tile we occupy.
    var tile = tiles[(tiles.length * Math.random())|0];
    // Find an unoccupied tile close by.
    var size = 1;  // FIXME: choose a size depending on the building type.
    tile = this.findNearestEmpty(tile, size);
    // Find a tile where this can be constructed.
    tile = this.findConstructionLocation(tile, buildingType);
    var builds = this.dependencyBuilds(buildingType, tile);
    // Find the nearest group around that tile.
    var groups = [];
    groups.push(this.addGroup(tile));
    this.projects.push({
      type: projectType.build,
      groups: groups,
      target: tile,
      builds: builds,
    });
    console.log('build project');
  },

  // Obtain control over a type of tile.
  // Includes an optional camp from which to take it, if it has it.
  conquerProject: function(tileType, campId) {
    // Find a tile where this tile type is.
    var tile;
    var campTiles = this.humanity.campFromId(campId).builtTiles;
    for (var i = 0; i < campTiles.length; i++) {
      if (this.humanity(campTiles[i]).b === tileType) {
        tile = campTiles[i];
        break;
      }
    }
    if (tile === undefined) { return; }
    // Find the nearest group around that tile.
    var groups = [];
    groups.push(this.addGroup(tile));
    this.projects.push({
      type: projectType.conquer,
      groups: groups,
      target: tile,
      camp: campId,
    });
    console.log('conquer project');
  },

  // Harm a specific adversary.
  // Targets residential buildings and buildings around them.
  warProject: function(tile, campId) {
    // Find the nearest group around that tile.
    var groups = [];
    groups.push(this.addGroup(tile));
    this.projects.push({
      type: projectType.war,
      groups: groups,
      target: tile,
      camp: campId,
    });
    console.log('war project');
  },

  // Add a random project.
  randomProject: function() {
    var projectTypes = Object.keys(projectType);
    var type = (projectTypeList.length * Math.random())|0;
    if (type === projectType.build) {
      // Random building.
      var buildingType = terrain.buildingTypes[
        (terrain.buildingTypes.length * Math.random())|0];
      this.buildProject(buildingType);
    } else if (type === projectType.conquer) {
      // Random camp, find a tile type it owns.
      var campId = (this.humanity.numberOfCamps * Math.random())|0;
      if (campId === this.camp.id) {
        campId = (campId + 1) % this.humanity.numberOfCamps;
      }
      var campTiles = this.humanity.campFromId(campId).builtTiles;
      var tileType =
        this.humanity(campTiles[(campTiles.length*Math.random())|0]).b;
      this.conquerProject(tileType, campId);
    } else if (type === projectType.war) {
      // Random camp, find a tile it owns.
      var campId = (this.humanity.numberOfCamps * Math.random())|0;
      if (campId === this.camp.id) {
        campId = (campId + 1) % this.humanity.numberOfCamps;
      }
      var campTiles = this.humanity.campFromId(campId).tiles;
      var tile = campTiles[(campTiles.length * Math.random())|0];
      this.warProject(tile, campId);
    }
  },

  // Return true if the project is done.
  isProjectComplete: function(project) {
    if (project.type === projectType.build) {
      return project.builds.length === 0;
    } else if (project.type === projectType.conquer
            || project.type === projectType.war) {
      // We have arrived to the target
      // (potentially killing enemies along the way).
      var humanityTile = this.humanity(project.target);
      if (humanityTile == null) { return false; }
      return humanityTile.c === this.camp.id;
    }
  },

  // Return an atomic operation to send to the server.
  runProject: function() {
    // Find a project to use.
    if (this.projects.length === 0) {
      // We need to create a project.
      this.randomProject();
    }
    console.log('projects:', JSON.stringify(this.projects, null, 2));
    // Complete the first project we have.
    var project = this.projects[0];
    if (this.isProjectComplete(project)) {
      this.projects.shift();
      return this.runProject();
    }
    // FIXME: what if there is nobody on the group's tile?
    // First, you need to perform all the builds.
    if (project.builds && project.builds.length > 0) {
      var build = project.builds[0];
      // If we're on the tile, build it and be done with it.
      var groupIsOnTile = false;
      for (var i = 0; i < project.groups.length; i++) {
        if (sameTile(project.groups[i].tile, build.tile)) {
          groupIsOnTile = true;
        }
      }
      if (groupIsOnTile) {
        project.builds.shift();
        // Send the construction information.
        return {
          at: terrain.keyFromTile(build.tile),
          do: terrain.planTypes.build,
          b: build.building
        };
      }
      // We need to go towards this building tile.
      var group = project.groups[(project.groups.length * Math.random())|0];
      var toTile = closestTowards(group.tile, build.tile);
      // FIXME: what if toTile is the same as the current tile?
      var fromHumanityTile = this.humanity(group.tile);
      group.tile = toTile;
      return {
        at: terrain.keyFromTile(group.tile),
        do: terrain.planTypes.move,
        to: terrain.keyFromTile(toTile),
        h: fromHumanityTile.h
      };
    }
    // Go to the target.
    // FIXME: give availability to choose between groups to move forward.
    var group = project.groups[(project.groups.length * Math.random())|0];
    var toTile = closestTowards(group.tile, project.target);
    var fromHumanityTile = this.humanity(group.tile);
    group.tile = toTile;
    return {
      at: terrain.keyFromTile(groupTile),
      do: terrain.planTypes.move,
      to: terrain.keyFromTile(toTile),
      h: fromHumanityTile.h
    };
  },

};


// Movement primitives.

var MAX_INT = 9007199254740992;

// Tiles a and b = {q,r} correspond to the same tile.
function sameTile(a, b) {
  return a.q === b.q && a.r === b.r;
}

// a and b are tiles = {q,r}.
function distanceBetweenTiles(a, b) {
  return (Math.abs(a.q - b.q) +
          Math.abs(a.r - b.r) +
          Math.abs(a.q + a.r - b.q - b.r)) / 2;
}

// Return the closest tileKey we can go to from atTileKey
// in order to go to the target toTileKey.
function closestTowards(atTileKey, toTileKey) {
  var accessibleTiles = terrain.humanTravel(terrain.tileFromKey(atTileKey));
  var toTile = terrain.tileFromKey(toTileKey);
  var closest;
  var shortestDistanceYet = Infinity;
  for (var tileKey in accessibleTiles) {
    if (closest === undefined) { closest = tileKey; continue; }
    var tile = terrain.tileFromKey(tileKey);
    var thisDistance = distanceBetweenTiles(tile, toTile);
    if (thisDistance < shortestDistanceYet) {
      shortestDistanceYet = thisDistance;
      closest = tileKey;
    }
  }
  return closest;
}


exports.findConstructionLocation = findConstructionLocation;
exports.dependencyBuilds = dependencyBuilds;
exports.Strategy = Strategy;
exports.projectType = projectType;
exports.projectTypeList = projectTypeList;
